Proposed New treatment of infix operators in MsML

Note that infix operators are not necessary. The main motivation for
providing them is the common usage of infix arithmetic operators
"+", "-", "*", and "/".  It is convenient to have an infix operator
for list "cons" and the list and string concatentation operators "@"
and are
reasonable 

------------------------------------------------------------------------------------------
Basis predefined infix operators (12):  [Basis, p. 23]

*   7
div 7  (or symbol "//")
mod 7  (or symbol "%", using the name from C)

+   6
-   6
^   6 

::  5r (right assoc by convention)
@   5r (right assoc for efficiency)

=   4 (special)
>   4
<   4
>=  4
<=  4
<>  4

There is the question of whether "div" and "mod" should be infix at
all, since the "quot" and "rem" functions are not infix (in fact, they
are not bound in the pervasive environment at all, and have to be
referred to as Int.quot and Int.rem). Why should "div", "mod" be treated
differently from "quot", "rem"?  It would be good to eliminate the two
alphanumeric infix identifiers and restrict infix operators to be
symbolic.

Note that in the syntax of type terms, "->" and "*" are infix
operators, with "*" being _variadic_ and of higher precedence than
"->". But types have a separate syntax.  Here we are only concerned
with core expressions and declarations.  But infix operator
identifiers can be used as the names of datatype constructors.


------------------------------------------------------------------------------------------
Infix symbolic identifiers declared in the SML/NJ compiler sources (base/compiler).
(15, only 1 of which is right associative)

infix 6 ++
infix -- infix 5 -- infix 6 --  (3 times)
infix 6 +++
infix 6 ---
infix 6 \/
infix 7 /\
infix -->
infix $ infix 3 $ (2 times?)
infixr 4 & (only infixr decl, in pickle-util.sml)
infix >>
infix :-:
infix // %% !!
infix 5 $$


Infix alphanumeric identifiers declared in compiler sources

infix upto  
infix atop  
infix 9 sub  
infix plus times 

------------------------------------------------------------------------------------------
Proposed extra  predefined infix identifiers (beyond those in the Basis):
[similar to Ada treatment of infix operators?]

--  (maybe this should be reserved for line comments?)
++
**
$$
%%
@@  (r?)
||  (possibly used to replace "div")
&&
!!
//  (but not \\, because of the use of "\" as an escape char)
<<
>>

1. All infix identifiers are symbolic
2. All infix identifiers are 2 characters long.
3. All are of precedence 8.
4  All are left-associative.
  (could designate a couple operators as right aasociative operators,
   but which ones?)

Comment 0:
  The idea is that these identifiers would have predefined infix
  properties. But they could be bound to values (in the usual way)
  in user code. and such bindings would be treated in the standard
  way, e.g., they could be exported from a structure.  The infix
  property would be inherent to the identifier, and not regarded as
  a special "binding" of the identifier as in (S)ML.  This means that
  we do not need a static environment to determine the "fixity" of an
  identifier. Instead we would invoke a fixed fixity "oracle".

  fixity : identifier -> precedence * associativity

Comment 1:
  Should we predeclare some subset as right associative?
  If so, how many and which ones?
  Should any such right-associative identifiers be visually or
  sylistically distinguished?

Comment 2:
  Probably it would be a good idea to replace the alphanumeric "mod"
  and "div" infix operators with symbolic operators. Possibly
  "div" -> //, "mod" -> "/!".

Comment 3:
  The short-circuiting logical operators "andalso" and "orelse" can't
  be replaced by (by default, call-by-value) infix operators, but
  perhaps "&&" and "||" (or some such) could replace them as keywords?
  
  
------------------------------------------------------------------------------------------
Typing issue

All infix identifiers, if and when defined, should be binary
functions, with types of the form:

   id: ty1 * ty2 -> ty3

that is, their argument should have a pair type and it should not be curried.

The result type ty3 is unrestricted, and so may be higher-order.

------------------------------------------------------------------------------------------
Syntax issue

The syntax of function declarations (their header or left-hand side in
particular, does not provide special syntax for currying. Thus if id
is an infix identifier, then

   fun p1 id p2 = rhs_exp 

and
 
   fun (p1 id p2) = rhs_exp 

are accepted and are equvalent to

   fun (op id) (p1, p2) = rhs_exp 

but curried forms like

   fun p1 id p2 p3 = rhs_exp 

or

   fun (p1 id p2) p3 = rhs_exp 

are not allowed, and should produce a syntax parsing error.

This is a change from the syntax of SML as presented in the Definition (Revised).
