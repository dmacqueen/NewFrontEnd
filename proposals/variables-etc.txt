NewFrontEnd/proposals/variables-etc.txt

Some thoughts on variables, namespaces, environments, scopes, etc.

Terms/concepts to be defined or understood:

  - identifier

  - symbol

  - variables

  - name spaces

  - (static) environment

  - bindings, binding and applied occurrences of variables

  - scope of a variable

  - shadowing

------------------------------------------------------------------------------------------
Name Spaces

* A source language phrase is made up of various kinds of lexical tokens.

  - punctuation symbols or characters (like "comma", "colon", "semicolon")
  - bracketing characters, like parentheses, normally coming in opening (left) and closing
    (right) pairs
  - identifiers, which include names of things (values, types, modules, signatures) and
    also record labels. Most identifiers are internally represented by a "symbol" type.

* We use various flavors of variables (values, tycons, type variables, modules, signatures).
  These can be organized into three "name spaces":

     1. Value: names of variables that occur in expressions and
        (binding) patterns, and names of data constructors. By
        convention, value variables are initial lower case and
	data constructors have initial caps (except for the
	infix symbolic exception "::").

     2. Type: names of type constructors (tycons) and type variables
        Convention: type constructors (other than "->" and "*" are
          initial lower case, while type variables are initial upper case.

     3. Module: names of structures, functors, _and_ their signatures.
        Convention: Structure and functor names have initial caps and
	use camel-case. Signature names are all caps, with underscore
        separating words.  A single capital letter is always assumed
        to be a module name.  [What about S1, S2a, S2A, etc?]
   
    datatype namespace
     = Value (* variables appearing in value expressions, notionally bound to values,
                plus and data constructors *)
     | Type (* names of tycons and type variables *)
     | Module (* structures, functors, and their signatures *)

    Note that type constructors and type variables inhabit the same
    name space, but that they can be distinguished based on the case
    of the initial (alpha) character.  Similarly, modules names and
    signature names are in the same name space but are distinguished
    by the capitalization convention.  We are abandoning the initial
    backquote lexical convention for type variables, along with the
    separate type variable name space.

    We should never need to worry about how to distinguish type
    constructors and type variables. Type constructors should always
    start with a lower-case letter and type variables should start
    with an upper-case letter. We stick with the informal convention
    used in (S)ML rather than adopting the Haskell convention that
    type constructors are capitalized.  There are usual exceptions for
    the symbolic, infix type constructors "->" and "*".

    Type variables may be bound or free in a given type
    expression. They can appear free in a type if they are bound in an
    expression/declaration context. Static scoping analysis will be
    needed to determine whether a type variable is (locally) bound or
    free in a type expression.

    Note that we do not need a record field label name space nor a
    "fixity" name space.  Field labels will be alphanumeric, and by
    convention will be initial lower case.  Whether "r.lab" is valid
    can be determined given the type of r, which should be a record
    type containing a field with label "lab".  Tuples will be treated
    as a distinct form, so numberic field labels will not be needed or
    allowed.

    Environments will consist of three component environments for the Value, Type,
    Module name spaces. The domains of these envionments will be sets
    of "atoms".
    
    We can have a variable and a type (constructor) named "x".  But
    "x" should not be the name of a type variable or a module or a
    signature, because of the capitalization conventions.
    


* Every identifier except record labels is used to name something, and these are the
  various flavors of "variables".  Each variable identifier should belong to a unique
  namespace, which tells you what kind of thing the variable _names_.

* We need to be able to do two things with a variable:

    1. bind them to something
    2. look them up in an environment (to interpret them; to find out what they are bound to)

  These operations relate to the notion of the "scope" of a variable, which is roughly the
  logical portion of a program in which their binding applies.

* Principle: every variable should belong to exactly one namespace 

* Principle: every variable should have an explicit binding occurrence (appear in a "binding") 

  Currently in SML, type variables occurring in expressions or function declarations
  may not have an explicit binding occurrence, but I view this as a
  mistake that needs to be corrected. Type variable bindings at the
  expression level must be made explicit.

* Should record labels belong to their own "label" namespace? 
  Labels can be considered as a means of accessing internal components of a
  record. Whether this means that they should be treated as variables is debatable,
  since we do not normally view records as "environments". For the sake of efficient
  access, we want to treat them as offsets in a compound value. Also
  labels used in "field access" expressions are not considered "bound"
  symbols -- instead, their validity depends on the type of the record
  being accessed.  A record is a labelled product, as opposed to a
  positional product indexed by component position in a tuple.
  
* It's not clear why we would need separate name spaces for modules and signatures.
  It seems likely that we do _not_ need separate name spaces for structures and
  functors, especially with HOF.

* Sometimes we want to distinguish classes of identifier lexically. For instance, we can
  use the convention that ordinary value variables have initial lower case while data
  constructor names have initial upper case. Such lexical conventions may, or may not, be
  "statically" inforced. But such lexical distinctions do not require distinct
  name spaces. E.g. we traditionally consider value variables and data constructor names
  to be in the same "value" namespace.

Variables

* All variables are bound ("there ain't no such thing as a free variable"), and have
  a unique binding occurrence; e.g. the subject of a val or fun declaraion, variables in
  _binding_ patterns in a function declaration, case expression, exception handler).

* Occurrences of a variable in its scope are called "applied occurrences".

* What do we need to know about a variable? 

  - its name, a string (atom?)

  - what namespace it belongs to (i.e. in which environment component is it bound).

  - its scope
    -- the idea of scope of a variable described here is incomplete, and the scope
       of a variable is not usually an _explicit_ attribute of a variable.
    -- the scope of a variable is probably not an attribute that needs to be a concrete
       attribute of the variable's representation
    -- Open or Closed scopes? [not clear how useful/important this distinction is]
      # if Closed, then an expression (or declaration?) that constitutes the scope
	 (e.g. of a let-bound or local-bound variable)
      # value variables exported by a structure are assumed to have Open scope
      # value variables bound at top level in the REPL have Open scope
      # pattern variables (occurrence in the pattern is a binding occurrence) have their
	 normal scope (e.g. rhs of a rule, body of a function)
      # the scope of variables bound in the local part of a local-in-end decl include the
	 body decl, in addition to their normal scope within the local declaration
      # if a value variable is bound at top level in a structure, but not exported, it has
	 Open scope (not the remaining sequence of decls in the structure) (?)
      # variables exported from a structure have Open scope (?)
    -- the scope of a variable naming a function that is part of a family of recursively
       defined functions includes the function bodies of the definitions in the family
    -- etc. (e.g. holes in scopes due to shadowing of a binding)

* We assume we need equality on variables, which may be based on a hash value for efficiency.
  The hash value would also (involved in) the key for environment mappings. It would
  seem to suffice to have the variable name be an _atom_ rather than a _string_, since the
  notion of an atom is motivated by the desire to have efficient equality (and finite maps).
  
* Value variables and module variables will (probably) have an assoiciated unique
  _dynamic_ variable used to refer to the runtime value to which it is bound during
  execution. These associated dynamic variables play no role in elaboration, and perhaps
  should not be part of the static representation of variables (as they are in SML/NJ).

* We assume that tycon and signature variables will not have a runtime representation
  but will be relevant only during elaboration and probably, in some altered form,
  during middle-end optimization (i.e. in FLINT or the equivalent type-sensitive
  optimization phases).

* Programming point: We want a variable with a closed scope to have the smallest
  possible scope.

* other information that would be useful (to a programmer)
  - source location of the binding occurrence of a variable
  - source locations of the applied occurrences of a variable, if any
  - if a variable has closed scope, are there any applied occurrences in its scope?
    if not, generate a warning message ("variable x bound but not used").

* Note that if type variables have explicit binding points, no lexical distinction
  (like a leading apostrophy) is needed for type variables.  We could have a convention
  that they be capitalized alphanumeric (and a corresponding convention that tycons be
  alphanumeric with an initial lower case letter).

* Question: What is the concrete syntax for type variable bindings in expressions
  and, in particular, in value bindings (val and fun)?  SML '97 has a rather "quick
  and dirty" solution to this issue.
  

------------------------------------------------------------------------------------------
* (Static) Environments

In current SML/NJ, all the name spaces are encoded in a single variable type, and
environments map that single variable type to "bindings", which is a tagged union
corresponding to the different name spaces (currently to many name spaces). [Presumably
this choice (around 1986) was thought to be more efficient than a per-namespace record
of environments.]   

Value variables can have two different bindings in scope at a given point: the normal
bound variable, and a "fixity" binding with an different, independent scope. This
is messy, but static infix bindings should be dropped anyway.

So lets assume that an environment is a record of separate environment mappings, one
for each name space, as in

datatype senv  (* static environment *)
  = {value : variable --> valueVar + datacon,
     type' : variable --> tycon + tyvar,  (* static semantics tycon or type variable *) 
     module : variable --> structure + functor + signature + fctsignature}

So to find the binding of a variable symbol v in a static environment e, we:

   (1) access its namespace, (ns = v.namespace)
   (2) use the name space to access the appropriate binding mapping, (b = e.<ns>,
       where <ns> is the label associated with the namespace ns).
   (3) apply the binding mapping to the variable symbol (binding = b v)


------------------------------------------------------------------------------------------
The question of _shadowing_ of bindings

* The policy in (S)ML toward shadowing is quite liberal, probably because of the REPL,
  where it is convenient to repeatedly "reload" source code.

* Could it, should it, be more strict in certain cases, e.g. within the body of a basic
  structure expression?

* Relation or interaction with the "type explicitness" question. E.g.

    local
      datatype d = A
    in
      val x = A
    end


------------------------------------------------------------------------------------------
Symbols (the concrete representation of identifiers)

  - Roughly, symbol == atom.

  - The _name_ of a symbol should be an atom.
    This means we don't have to deal with a hash of a string name; that is implicit.
    We also can define finite atom sets and finite mappings using the Atom structure
    together with finite set and map functors from the smlnj-lib library.

  - Thus, equality of symbols reduces to atom equality.

  - But we are not interested in equality of symbols across different name spaces.

  - A symbol should belong to an name space, which is implicit in where and how it is
    bound and used.
    Two symbols in different name spaces may have the same name, but this is
    harmless -- there is no ambiguity. But we don't want a variable and a datacon to
    have the same name, which is why they belong to the same name space.  Similarly, we
    don't want to have confusion of type constructors and type variables, which can occur
    together in type expressions.

  - A symbol should have at most one binding in a given name space!:? (see shadowing)
    This means we can use library finite map functors for the components of the environment
    record. [Shadowing is supported by the normal behavior of the finite map abstraction.]
