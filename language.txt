sml/Dev/github/NewFrontEnd/language.txt

Notes on proposed language changes

Let's use "MSML" as a working of the language we are working on, where MSML is an
acronym for "MacQueen's Successor ML".  Note that here the capital S stands for
"Successor", not "Standard".  This language would be a derivative or dialect of
(Standard) ML, which is my preferred name for Standard ML (SML).

Below is my suggested list of changes, which could be interpreted as relative mainly
to current SML/NJ or, alternatively, to the SML Definition (Revised), i.e. "official"
Changes are to the Core language unless annotated by "[Modules]" or "[Modules*]". where
the "[Modules*]" annotation indicates changes (from the Defintion (Revised)) that have
already been made in SML/NJ.

Standard ML '97.

1. Deletions

1.1. inference of binding points for expression-level type variables

  This is hard to describe, implement, and remember how it works.
  Variables, including type variables, should have an explicit binder construct
  in the concrete syntax.

1.2. the "open" declaration form

  Deleting open declarations forces programmers not to use it (a good thing). The
  usual replacement is to introduce in each structure a bunch of short abbreviations
  for external modules that are used in that structure.  This pattern could be codified
  in concrete syntax using some sort of "import" declaration.

  Also, deleting "open" means that it cannot be used within expressions, thus avoiding
  the implicit _declaration_ of types and structures within expreesions.

1.3. static (type/module) declarations within expressions

  [Moto: Keep the core and module levels separate.]
  What does it, or should it, mean to have a (statically generative) datatype declaration
  in the body of a recursive function.

1.4. Equality type variables 

  How to deal with generic equality (or not)?


3. Additions  
 
3.1. record combination (or "overlaying")

  Let's initially introduce a syntax form e1 ++ e2 where e1 and e2 must have record types

    r1 ++ r2 is the (environmental) overlay of the r2 label mapping on top of the r1 mapping.

  This allows for both addition of fields and functional updates of fields of a base
  record (r1).

3.2. [Modules] Signature functors.

  Signatures that are defined relative to structure parameters (or _a_ structure parameter)

3.3. [Modules*] Higher order functors.

  As implemented in SML/NJ since version 0.93 (1993.02?), but ...

3.3. [Modules] Proper, native, concrete and abstract syntax for curried functors and partial
  applications thereof.

3.4. [Modules*] "where structure" clauses modifying signatures (not just "where type").


4. Other Changes

4.1. [Modules] Replacement of open and include for defining extensions of structures/signatures.
   How about _extension_ functors and signature functors that add elements to their argument
   stuctures or signatures?  But not supporting any sort of "merging" of new
   declarations/specifications with existing ones in the parameter. [Viewing that as
   a separate dimention of _extension_ or _refinement_ of an existing structure/signature.


5. Other issues

5.1 Symbols vs alternatives

  Symbols are kind of hashed strings with the hash number also encoding a "name space".
  This may be a bit too clever. What are the simpler alternatives?
  
5.2 Exceptions

  The semantics of exceptions is rather naive and by now there might be a "better" way
  of defining exceptions. I've always thought that it would be better to have exception
  declarations be "static" in some sense, but it is not clear what this would mean.
  Have to look into "algebraic exceptions", whatever those are.

