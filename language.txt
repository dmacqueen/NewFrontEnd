repository: https://github.com/dmacqueen/NewFrontEnd 
file: language.txt

Notes on proposed language changes
DBM, 2024.11.

0. Introduction

Let's use "MSML" as a working name for the language we are working toward, where MSML is
an acronym for "MacQueen's Successor ML". Note that here the capital S stands for
"Successor", not "Standard". This language (MSML) should be considered a derivative
or dialect of "(Standard) ML", which is my preferred name for Standard ML (SML or (S)ML).

Below is my suggested list of changes, which could be interpreted as relative mainly
to current SML/NJ or, alternatively, to the SML Definition (Revised), i.e. "official"
Changes are to the Core language unless annotated by "[Modules]" or "[Modules*]". where
the "[Modules*]" annotation indicates changes (from the Defintion (Revised)) that have
already been made in SML/NJ.

The point of these changes is not to produce a "more powerful" language, but to simplify
where possible, improve some fairly obvious weaknesses or mistakes in the language
design and add a small bit of functionality of proven utility (mainly record overlay
and signature functors).

These proposals have not (yet) been "reconciled" with the Successor ML proposals in the
Successor ML repository Wiki pages.

I consider Standard ML '97 to be an incomplete revision based on self-imposed restrictions
and [Milner's] worries about resistance or objections from "commercial" entities
[e.g. Abstract Hardware, later Harlequin].


------------------------------------------------------------------------------------------ 
1. Deletions

1.1. [Core] No inference of binding points for expression-level type variables

  The existing feature is hard to describe, to implement, and to remember how it works.
  All variables, including type variables, should have an explicit binder construct
  in the concrete syntax. This was addressed in SML '97, but in a rather ad hoc
  way.  What is a better notation for expression level type variable binders?

  [This might relate to the possible introduction of some form of "1st-class"
  polymorphism, e.g. for function arguments or data constructor arguments
  (as in Haskell?).]

1.2. [Core+Modules] The "open" declaration form

  Deleting open declarations forces programmers not to use it (a good thing). The
  usual replacement is to introduce in each structure a bunch of short abbreviations
  for external modules that are used in that structure.  This pattern could be codified
  in concrete syntax using some sort of "import" declaration.

  Also, deleting "open" means that it cannot be used within expressions, thus avoiding
  the implicit _declaration_ of types and structures within expreesions.

1.3. [Core] No static (type/module) declarations within expressions

  [Moto: Keep the core and module levels separate.]
  What does it, or should it, mean to have a (statically generative) datatype declaration
  in the body of a recursive function.  [Karl won't like this!]

1.4. [Core+Modules] Equality type variables (equality polymorphism)

  If these are removed, how would we deal with generic equality (or not)?

  See [Appel94], Section 4.

1.5. [Core] Lexically scoped infix declarations

  These were a bad idea carried over from the POP 2 tradition.

  What are other options for user defined infix operators?  Haskell style infixes?

  [We dropped infix _specs_ in signatures a long time ago, as well as the export of
  such specs from structures. Horrendous interaction with the open declaration. Would
  it be a terrible thing if we did not support user-defined infix operators at all?]
  
1.6. [Modules, Controversial?] Sharing equations in signatures

  I would like to drop sharing equations like

     sharing A.t = B.s

  in signatures, letting all required sharing be specified by

  (a) definitional type and structure specifications (internal), and
  (b) where clauses modifying signatures (external).

  I my experience with the SML/NJ code, this is entirely feasible, but I know of
  contrived examples where sharing equations seem to be required. The question is:
  are there natural, non-contrived examples of module code where equational
  "sharing" specs are necessary.

  Getting rid of sharing equations would make the "instantiation" process in
  module elaboration much simpler. It might also be the case that where clauses
  are easier to understand than sharing equations for novice users of the language.

1.7. [core] The "abstype" declaration

  Which is redundant given structures with opaque signature ascription.

1.8. [Core] The "while" expression form

  Redundant. Use recursion instead for iteration. Same reason we don't have a "loop"
  expession form.
  

------------------------------------------------------------------------------------------
3. Additions
 
3.1. [Core] record combination (or "overlaying")

  Let's initially introduce a syntax form e1 ++ e2 where e1 and e2 must have record types

    r1 ++ r2 is the (environmental) overlay of the r2 label mapping on top of the r1 mapping.

  This allows for both addition of fields and functional updates of fields of a base
  record (r1).

3.2. [Core] Records vs tuples

  Currently, tuples are just a special case of records, with successive numeric number
  labels (symbols) "1", "2", ..., "<n>" for some positive n. The null tuple is treated
  specially, and is the unique value of the type unit.

3.3. [Modules*] Higher order functors.

  As implemented in SML/NJ since version 0.93 (1993.02?), but ...

3.4. [Modules] Signature functors.

  Signatures that are defined relative to structure parameters (or _a_ structure parameter)

3.5. [Modules] Higher-order functor concrete and abstract syntax.

  Proper, native, concrete and abstract syntax for curried functors and partial
  applications thereof.  I guess one might also introduce curried signature functors?
  
  [Note: currently SML/NJ does not provide a proper abstract syntax for the module level.]

3.6. [Modules*] "where structure" clauses modifying signatures (in addition to "where type").

3.7. [Core] Adding a "variable type declaration" construct.
 
  This would allow "pre-declaration" of a variable before the definition of the variable.
  Mainly justified by its use for code self-documentation, but it would also support
  simple and efficient "polymorphic recursion".

  This was actually a feature of Burstall's NPL, an early precursor of SML. Also supported
  in Haskell.


------------------------------------------------------------------------------------------
4. Other Changes

4.1. [Modules] Replacement of open and include for defining extensions of structures/signatures.

   How about _extension_ functors and signature functors that add elements to their argument
   stuctures or signatures?  But not supporting any sort of "merging" of new
   declarations/specifications with existing ones in the parameter. [Viewing that as
   a separate dimention of _extension_ or _refinement_ of an existing structure/signature.

4.2. Correct errors in the concrete syntax.

   For example, the 2 shift/reduce ambiguities in the MLyacc grammar: (1) nested matches,
   and (2) somewhere in the module system grammar.
   

------------------------------------------------------------------------------------------
5. Other issues

5.1. [General] Symbol and their representation

  Symbols are kind of hashed strings with the hash number also encoding a "name space".
  This may be a bit too clever. What are the simpler alternatives?
  
5.2. [General] "Dynamic" Exceptions

  The semantics of exceptions is rather naive and by now there might be a "better" way
  of defining exceptions. I've always thought that it would be better to have exception
  declarations be "static" in some sense, but it is not clear what this would mean.
  Have to look into "algebraic exceptions", whatever those are.

5.3. Optimized data constructor representation vs (partial) abstraction

  This is a known issue that could probably be solved by using "functor inlining", but
  the interaction with higher-order functors is not clear. Functor inlining would probably
  need to be _deep_ or _recursive_ inlining to deal with functor arguments (and results?).

5.4. "Recursive" modules (signatures, structures, functors)

  These have been studied (notably in Dreyer's PhD Thesis), but the payoff does not seem
  to justify the added complexity involved, both static and dynamic.

5.5. Marcros

  No, because of terrible interaction with the type system, type errors.

5.6. Type variable notation

  I've never been fond of the 'a type variable notation. I think it would have been
  better to use initial letter case to distinguish between type constructor names and
  type variable names. We could adopt the Haskell convention, where type constructors
  are capitalized and type variables are lower case, but the opposite would be more
  consistent with SML notational history, i.e. type variables are capitalized alphanumeric
  names and type construcotors start with a lower-case character ("int" vs "X").  We would
  still support the two primitive, symbolic type constructor names "->" and "*" as special
  cases.

  The Standard ML notation lead to the ''a equality type variable variant. We would not
  need this distinction if we drop equality polymorphism.

5.7. Technologies for lexical analysis and parsing.

  Should we continue to use MLlex and MLyacc, or are there better tools to replace them?

  Should we use a "manual", e.g. recursive descent, style of parser (e.g. maybe the
  smlfmt parser, apropriately modified?)?

5.8. [Core] The problem of combining clausal and curried function definitions.

5.9. Types only structures and their signatures.

  Some structures contain only type declarations. Often in this case their signatures
  are entirely redundant, so their signatures are not necessary or useful?


------------------------------------------------------------------------------------------
6. Discussion

6.1. Are the suggested changes "backward compatibe"?  No. Too limiting.

   Maintaining backward compatibility is not one of my goals.

6.2. What is the impact of the changes on the Basis and SMLNJ libraries?

6.3. What about formal definition of the modified language?

  There should be a formal definition of the modified language. This could be achieved
  in various ways:

  (a) Modifying the existing Definition (Revised), as in the Successor ML repository.
      [What about the LaTeX macros? Missing index?]

  (b) Modifying the existing TWELF formalization written by Harper and Crary.

  (c) Using a new semantic definition technology?

  What does Bob say?

6.4. What (else?) was wrong with the original (Standard) ML design and its methodology?

  See, for instance, [MacQueen94].

  Are there good ideas from OCaml or Haskell (or whatever) that should be considered for
  inclusion in the list of proposed changes?  Infix operators, for instance?

6.5. The "open" declaration and "include" specifications

  These have long been known to be problematic. The original designs should be viewed
  as initial failed attempts to provide some sort of module or signature "calculus",
  meaning constructs or operations for combining or extending previously defined
  structures and signatures.  Need some new ideas.

6.6. Curried functors.

  These were originally added as somewhat clumsy "derived forms" or syntactic sugar. Then
  the FLINT group made the scheme more complicated in their revision of module elaboration.
  Perhaps curried functors are not worth supporting (given that most of the SML implementations
  never implemented higher-order functors, since they were left out of the 1997 revision).


------------------------------------------------------------------------------------------
7. Successor ML proposed changes

  Here I am using

    https://smlfamily.github.io/successor-ml/OldSuccessorMLWiki/Successor_ML.html

  as the reference document for proposed Successor ML changes.
  Note that several of the links to the descriptions of changes on this page are dead.

  Here are my reactions to the proposed Successor ML changes.
  Generally I would prefer not to make changes that add features and complexity.
  Keep it simple!

7.1. Line comments

  OK. Don't much care, but probably it would be useful and popular.

7.2. Excapes in strings

  OK. Don't much care. Minor bullet-proofing.

7.3. Extended syntax for literals.

  OK. Don't much care. Would not affect me.

7.4. Funtional record extension and row capture

  I much prefer a single record overlay "operator" (syntax form) as suggested in 3.1 above.
  This captures the useful functionality in a much simper way. Originally suggested by
  Wand many years ago and studied by others (R\'emy, ...).

  I don't like the introduction of another special class of variables, namely row variables.

  I guess a parallel form for record type overlays might be useful, but I would not consider
  it necessary.

7.5. Functional record update

  Same as 7.4.

7.6. Record labels and fields (?)

  Don't like. Too "cute".

7.7. Disjuctive patterns

  OK. Already in SML/NJ for many years.

7.8. Generalized layered patterns to conjuntive patterns

  No. Added complexity with little gained.

7.9. Match guards.

  No. Messes up the simplicity of pattern matching.

7.10. Simplifying val rec syntax

  OK, but even better, lets just get rid of val rec, etc.  (I never use it!)

7.11. Withtype in signatures.

  Done (in SML/NJ).

7.12. Fixed scoping for manifest type specifications

  OK. Seems to fix an obvious, unintended, design bug.

7.13. Degrade abstype to derived form

  No. Just get rid of abstype.
  It has effectively been abandoned in practice.

7.14. Haskell-like declaration prootypes/signatures

  The description seems to have been lost!

  If this is actually 3.7 above, I'm for it.

7.15. Option bar before first match clause

  A small concrete syntax tweak for editing convenience.
  Don't particularly like.
  What is the general principal?

7.16. Disallow non-exhaustive patterns in polymorphic bindings

  OK.  Could also just make non-exhaustive pattern matches an error, period.

7.17. More liberal type sharing

  Description of the change is missing (dead link). 

  Don't know what this refers to.

7.18. "where" constraints for structures

  Description of the change is missing (dead link). 

  I think this has already been implemented in SML/NJ since around 1996.

7.19. Drop "and" in "where type" constraints

  OK. Fixes a syntax design bug.
  Is this the shift/reduce conflict in the  module syntax?

7.20 Derived "do" declarations

  OK. Already implemented in SML/NJ as a Successor ML extension.

  Doesn't do much, but probably would be better to consider "do e" as syntactic
  sugar for

     val () = e

  where we would have to use the ignore function in cases where e returns a non
  unit value.

7.21. Fixing various minor issues with the formal syntax.

  Sure. Milner and the rest of us didn't know how to properly define a syntax.
  This whole issue needs to be rethought and brought into the 21st century.

7.22. Fixing various minor issues with the formal semantics.

  Not clear that retaining the Definition's semantic formalism is the best
  course. How would an expert do this with today's knowledge and formalisms?

7.23. Quoting/anti-quoting

  OK? Need to consult with actual users of the feature.

  This should also apply to the "lazy" extension.


------------------------------------------------------------------------------------------
8. Bibliography

[Appel94]: Andrew Appel, A Critique of Standard ML, 1994. [full info in SML History bib]]

[MacQueen94]: David MacQueen, Reflections on Standard ML, 1994. [full info in SML History bib]]

[The above papers are available in the SML History archive, in the design/critiques directory.]

[Harper*]: Type classes in ML (paraphrased).

[What else?]
