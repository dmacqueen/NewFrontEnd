https://github.com/dmacqueen/NewFrontEnd/language.txt

Notes on proposed language changes
DBM, 2024.11.

Let's use "MSML" as a working of the language we are working on, where MSML is an
acronym for "MacQueen's Successor ML". Note that here the capital S stands for
"Successor", not "Standard". This language (MSML) should be considered a derivative
or dialect of "(Standard) ML", which is my preferred name for Standard ML (SML).

Below is my suggested list of changes, which could be interpreted as relative mainly
to current SML/NJ or, alternatively, to the SML Definition (Revised), i.e. "official"
Changes are to the Core language unless annotated by "[Modules]" or "[Modules*]". where
the "[Modules*]" annotation indicates changes (from the Defintion (Revised)) that have
already been made in SML/NJ.

The point of these changes is not to produce a "more powerful" language, but to simplify
where possible, improve some fairly obvious weaknesses or mistakes in the language
design and add a small bit of convenient functionality (mainly record overlay and signature
functors).

These proposals have not (yet) been "reconciled" with the Successor ML proposals in the
Successor ML repository Wiki pages.

I consider Standard ML '97 to be an incomplete revision based on self-imposed restrictions
and worries about resistance or objections from "commercial" entities
[e.g. Abstract Hardware, Harlequin].

1. Deletions

1.1. [Core] No inference of binding points for expression-level type variables

  This feature is hard to describe, to implement, and to remember how it works.
  All variables, including type variables, should have an explicit binder construct
  in the concrete syntax. This was addressed in SML '97, but in a rather ad hoc
  way.  What is a better notation for expression level type variable binders?

  [This might relate to the possible introduction of some form of "1st-class"
  polymorphism, e.g. for function arguments or data constructor arguments
  (as in Haskell?).]

1.2. [Core+Modules] The "open" declaration form

  Deleting open declarations forces programmers not to use it (a good thing). The
  usual replacement is to introduce in each structure a bunch of short abbreviations
  for external modules that are used in that structure.  This pattern could be codified
  in concrete syntax using some sort of "import" declaration.

  Also, deleting "open" means that it cannot be used within expressions, thus avoiding
  the implicit _declaration_ of types and structures within expreesions.

1.3. [Core] No static (type/module) declarations within expressions

  [Moto: Keep the core and module levels separate.]
  What does it, or should it, mean to have a (statically generative) datatype declaration
  in the body of a recursive function.  [Karl won't like this!]

1.4. [Core+Modules] Equality type variables (equality polymorphism)

  If these are removed, how would we deal with generic equality (or not)?

  See [Appel94], Section 4.

1.5. [Core] Lexically scoped infix declarations

  These were a bad idea carried over from the POP 2 tradition.

  What are other options for user defined infix operators?  Haskell style infixes?

  [We dropped infix _specs_ in signatures a long time ago, as well as the export of
  such specs from structures. Horrendous interaction with the open declaration. Would
  it be a terrible thing if we did not support user-defined infix operators at all?]
  
1.6. [Modules, Controversial?] Sharing equations in signatures

  I would like to drop sharing equations like

     sharing A.t = B.s

  in signatures, letting all required sharing be specified by

  (a) definitional type and structure specifications (internal), and
  (b) where clauses modifying signatures (external).

  I my experience with the SML/NJ code, this is entirely feasible, but I know of
  contrived examples where sharing equations seem to be required. The question is:
  are there natural, non-contrived examples of module code where equational
  "sharing" specs are necessary.

  Getting rid of sharing equations would make the "instantiation" process in
  module elaboration much simpler. It might also be the case that where clauses
  are easier to understand than sharing equations for novice users of the language.


3. Additions  
 
3.1. [Core] record combination (or "overlaying")

  Let's initially introduce a syntax form e1 ++ e2 where e1 and e2 must have record types

    r1 ++ r2 is the (environmental) overlay of the r2 label mapping on top of the r1 mapping.

  This allows for both addition of fields and functional updates of fields of a base
  record (r1).

3.2. [Core] Records vs tuples

  Currently, tuples are just a special case of records, with successive numeric number
  labels (symbols) "1", "2", ..., "<n>" for some positive n. The null tuple is treated
  specially, and is the unique value of the type unit.

3.3. [Modules*] Higher order functors.

  As implemented in SML/NJ since version 0.93 (1993.02?), but ...

3.4. [Modules] Signature functors.

  Signatures that are defined relative to structure parameters (or _a_ structure parameter)

3.5. [Modules] Higher-order functor concrete and abstract syntax.

  Proper, native, concrete and abstract syntax for curried functors and partial
  applications thereof.  I guess one might also introduce curried signature functors?
  
  [Note: currently SML/NJ does not provide a proper abstract syntax for the module level.]

3.6. [Modules*] "where structure" clauses modifying signatures (in addition to "where type").

3.7. [Core] Adding a "variable type declaration" construct.
 
  This would allow "pre-declaration" of a variable before the definition of the variable.
  Mainly justified by its use for code self-documentation, but it would also support
  simple and efficient "polymorphic recursion".

  This was actually a feature of Burstall's NPL, an early precursor of SML. Also supported
  in Haskell.


4. Other ChangesXQ

4.1. [Modules] Replacement of open and include for defining extensions of structures/signatures.

   How about _extension_ functors and signature functors that add elements to their argument
   stuctures or signatures?  But not supporting any sort of "merging" of new
   declarations/specifications with existing ones in the parameter. [Viewing that as
   a separate dimention of _extension_ or _refinement_ of an existing structure/signature.

4.2. Correct errors in the concrete syntax.

   For example, the 2 shift/reduce ambiguities in the MLyacc grammar.
   

5. Other issues

5.1. [General] Symbol and their representation

  Symbols are kind of hashed strings with the hash number also encoding a "name space".
  This may be a bit too clever. What are the simpler alternatives?
  
5.2. [General] "Dynamic" Exceptions

  The semantics of exceptions is rather naive and by now there might be a "better" way
  of defining exceptions. I've always thought that it would be better to have exception
  declarations be "static" in some sense, but it is not clear what this would mean.
  Have to look into "algebraic exceptions", whatever those are.

5.3. Optimized data constructor representation vs (partial) abstraction

  This is a known issue that could probably be solved by using "functor inlining", but
  the interaction with higher-order functors is not clear. Functor inlining would probably
  need to be _deep_ or _recursive_ inlining to deal with functor arguments (and results?).

5.4. "Recursive" modules (signatures, structures, functors)

  These have been studied (notably in Dreyer's PhD Thesis), but the payoff does not seem
  to justify the added complexity involved, both static and dynamic.

5.5. Marcros

  No, because of bad interaction with the type system, type errors.

5.6. Type variable notation

  I've never been fond of the 'a type variable notation. I think it would have been
  better to use initial letter case to distinguish between type constructor names and
  type variable names. We could adopt the Haskell convention, where type constructors
  are capitalized and type variables are lower case, but the opposite would be more
  consistent with SML notational history, i.e. type variables are capitalized alphanumeric
  names and type construcotors start with a lower-case character ("int" vs "X").  We would
  still support the two primitive, symbolic type constructor names "->" and "*" as special
  cases.

  The Standard ML notation lead to the ''a equality type variable variant. We would not
  need this distinction if we drop equality polymorphism.

5.7. Technologies for lexical analysis and parsing.

  Should we continue to use MLlex and MLyacc, or are there better tools to replace them?

  Should we use a "manual", e.g. recursive descent, style of parser (e.g. maybe the
  smlfmt parser, apropriately modified?)?

5.8. The problem of combining clausal and curried function definitions.


6. General Discussion

Are the suggested changes "backward compatibe"?  No. Too limiting.

What is the impact of the changes on the Basis and SMLNJ libraries?

What about formal definition of the modified language?

What was wrong with the original (Standard) ML design and the underlying methodology.
See [MacQueen94].

Are there good ideas from OCaml or Haskell (or ?) that should be considered for
inclusion in the list of proposed changes?


7. Bibliography

[Appel94]: Andrew Appel, A Critique of Standard ML, 1994. [full info in SML History bib]]

[MacQueen94]: David MacQueen, Reflections on Standard ML, 1994. [full info in SML History bib]]

[What else?]
