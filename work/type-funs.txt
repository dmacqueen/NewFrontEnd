Type Functions: optimizing their application (i.e. type term beta-reduction)

* Idea: compile the body of a type function (a type term) into "code" that builds the result
  out of the parameters and the immutable subterms of the body (the subterms not containing
  a parameter variable).

Example:

type ('a, 'b) t = 'a * (int -> string) -> 'b

Here the code would be something like

     let t1 = int -> string (* bindinig t1 to a constant term *) 
      in \(p1, p2). arrow (times (p1, t1), p2)

OR

     let val t1 = CONTty (arrowTyc (CONty (intTyc, nil) -> CONty (stringTyc, nil)
         (* bindinig t1 to the constant, immutable term (int -> string) *) 
      in \(p1, p2). CONTty (arrowTyc (CONty (typleTyc (2, [p1, t1])), p2)


where p1 and p2 correspont with 'a and 'b.

Then only the arrow and times nodes of the body of the defn are copied when applying the
type function.  The immutable subterm "int -> string" is not copied and is shared by all
the contracta.
