NewFrontEnd/work/bug319.txt

Record of work on legacy issue #319 (and #344 from Crary and smlnj issue #278)
The approach is to do a deep clean-up of module elaboration (elabmod.sml, sigmatch.sml, instantiate.sml, evalent.sml, etc.) to remove last vestiges of FLINT modifications.  As a side issue, we can also move
typcath (types.sml) and TKind (ElabData/basics/tkind.sml) into the Elaborator/modules directory, where they
are used.  TKind could possibly be moved somewhere where it could be shared by the elaborator and by FLIINT.

Problem: Functor with opaque result signature is not producing abstract ("sealed") result structure.
  - in Elaborator/elaborate/elabmod.sml, constrStr (constrainStr) is not called correctly because of
    the value of the "curried" argument of elabFct.  Planned fix.  Get rid of curried functors as a
    form of syntactic sugar, derived form.

Have to get rid of obscuring FLINT constructions (internal "derived" forms) that may have originally
been introduced to support curried functor syntax.

** What are the basic elements of module elaboration?

- syntax trees (Ast; Parse/ast/*)
- abstract syntax (Absyn, VarCon [Variable]; ElabData/syntax/absyn.*, varcon.sml)
- static module representations (Modules, ModuleUtil, ModuleId; ElabData/modules/*)
- static environments (StaticEnv, Bindings, Lookup, ElabData/statenv/*)
- (Dynamic) Access
- types (Types, ElabData/types)
    (tycpath generated by elaboration, but not used in the front end, try to eliminate,
     depends of TKind defined in ElabData/basics/tkind)

- Elaboration [Core] (ElabType, ElabCore; ElabUtil? Elaborator/types/*, Elaborator/elaborate/*)
- Elaboration [Modules] (ElabMod, ElabSig; ... ) 
- Elaboration [Modules, support] 
    entities, entity expressions and their static "evaluation" (EvalEnt)
    entity paths
    entity path contexts
    signature instantiation (Instantiate, Elaborator/modules)
    signature matching (Sigmatch; Elaborator/modules/sigmatch.*)
    module ids, pickling, (per)stamps, machinery supporting cutoff recompilation
      (how "orthogonal" or "separable" is this stuff to the basic line of module elaboration?)
    "special" symbols (internal derived forms) -- can we eliminate all these?

CONJECTURE: the tycpath type in Types defines roughly the types of entity expressions (and hence the
  types of entities?).  Similarly, the type TKind.tkind may correspond to the kinds of entity variables
  (TP_VAR tycpaths).  In the elaborator, TKind is referenced only in the Instantiate
  (Elaborator/modules/instantiate.sml) module.

  The tycpath constructors appear in the front end only in enteval.sml, sigmatch.sml, instantiate.sml
    tycpath in Elaborator/elabmod.sml, evalent.sml, instantiate.sml, sigmatch.sml 
      in ElabData/modules.sml, absyn.sml, types.sml
    TP_VAR in instantiate.sml
    TP_TYC in instantiate.sml
    TP_FCT in evalent.sml, sigmatch.sml
    TP_APP in evalent.sml
    TP_SEL in instantiate.sml
  In FLINT:
    TKind in transtkind.sml
    tycpath in transtypes.sml
    TP_VAR in transtypes.sml
    TP_TYC in transtypes.sml
    TP_FCT in transtypes.sml 
    TP_APP in transtypes.sml 
    TP_SEL in transtypes.sml 
    
Probably, at least, or as a first step, TKind and tycpath could me moved into Elaborate/modules?  The special generative tycons (GENtyc) with tyckind=FLEXTYC could be modeled as an alternative form of tycon (tycon', which would only have a tycpath as contents) in instantiate.sml? This would allow the removal of tycpath from earlier, non-module parts of elaboration (and in particular from types.sml).  This is because tycpath and hance TKind seem only relevant to instantiate.sml and perhaps sigmatch.sml and evalent.sml.

tkind.sml (defining structure TKind) and be moved from ElabData/basics to Basics/?.


** Curried functors (to be removed for simplification)

* Ast:  BaseFct can represent a curried functor in the case where the parameter list has lengh > 1.
  We can simplify by simply supposing/requiring (without changing Ast) that the BaseFct parameter list is
  always of length 1 (the non-curried functor case).  So Ast remains unchanged for the time being, but
  later we could simplify by making the functor parameter be a parameter instead of a list of parameters.
  where a parameter is a parameter name and a signature.s

* elabmod-fix.sml:
  
