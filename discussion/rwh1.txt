// discussion/rwh1.txt (originally rh-response.txt)
// Bob Harper's [RWH] initial response to proposals/language.txt
// 2024.11.13 (?)

Some responses, in no particular order:

Karl's version of smlyacc and smllex is far better than the original because it avoids writing disembodied fragments of code that manage to be stitched together to a coherent whole.  It's very nice, and should be adopted.

Karl's KML variant of SML has lots of interesting ideas that could/should be adopted, and the code base may prove useful for writing a reference implementation.  It compiles to Standard ML, but uses module declarations in the core language, and hence requires Moscow ML to compile the generated code.  It would be great if SML/NJ could be linked to KML as its backend.

The Sterling-Harper paper on modules provides what I now think is the definitive "core type theory" for SML, and we should build around that as the intended internal language.

The name sML = successor ML is a good working name, and we should use that for the time being.  The language needs a name.  The earlier efforts on sML were squashed in an ugly manner by Robin's intervention, no doubt goaded by others, but the ideas are still there, by and large.

Thare are many mistakes and poor choices that ruin the experience for many people.  I can name a few here, but I am certain that I am forgetting a whole bunch more.
    1. Eliminate 'a requirement for type variables.  We lexically distinguish identifiers that need no lexical distinction and lexically clash identifiers that need distinction (constructors vs values).  We can try upper case for type variables, I would have to see how it looks.  But watch out: "type t" in a signature is declaring a type variable for use in the remainder of that signature; the "t" used here should not be in any way at variance with other uses of type variables.
    2. Eliminate piss-poor equality types and equality type variables entirely.  If we want a module inference mechanism, see the Chakravarty-Dreyer-Harper-Keller paper on modular type classes.  We should either do it properly, or not at all.
    3. Fix stupid shift-shift and shift-reduce conflicts in the grammar.  These are due to the no-closing indicator on cases's that could be fixed easily, perhaps case match end.  Relatedly, using "=" for the clauses of a fun declaration causes needless pain when editing code.  Make these "=>" just like any other match.  Even better, do away with "fun" entirely, or migrate it into the "fn" notation but with a name for "self" to allow (mutual) recursion.  eg, val fact = fun f 0 = 1 | f n = n * f (n-1).
    4. Eliminate infix.  The Haskell solution, in some form, is the best option, but do not eliminate the ability to write infix applications!
    5. Pre-specificy values that will eventually (what is the region of interest?) be declared, so that one can write val x : X -> X and later (not too far in some sense) write val x = fn y => y, or similar.
    6. The "exception" declaration should be renamed "extension", a la KML for introducing a dynamically new class in the type clsfd of classified values with dynamically generated classifiers.  See PFPL for discussion.  There is no such thing as a "static exception", btw.  Leroy stupidly shoved this into O'Caml to be different, and (a) it is unsound and cannot be fixed, and (b) has been overridden by Garrigue with a proper generative exception mechanism.  Incidentally, classes of unit type, much like constructors of unit type in the static case of a datatype, are what you're calling "symbols".  Moreover, these provide bullet-proof confidentiality and integrity guarantees in code that uses them for security-motivated applications.
    7. Integrate modules and core language more thoroughly to allow local structure, functor, and even signature declarations.  There is no reason not to do this.
    8. Eliminate the pathetic imperative programming syntax that no one ever ever ever uses or used for anything.  However, the Haskell-like syntax for sequencing is rather nice, passing along both a value and the effect generated by the sequence in turn.
    9. Integrate datatypes and modules properly using my "data signatures" and "data structures" proposal.  eg, one may write "signature LIST = data type A list con nil : A list  con cons : A * A list -> A list end", then write "data structure List : LIST" to get the default implementation.  No more redundancy between dec's and spec's of data types.
    10. Integrate lazy data types in a natural way such that pattern matching is the means of forcing evaluation of arguments to lazy constructors.  Does not require "by name" variables!  Does not ruin the rest of the language!  It's an isolatable notion that could/should/would be adopted.
    11. Integrate letcc/throw, no excuses, no regrets, it's the right thing to do.
    12. Definitely allow type definitions in signatures, where and sharing clauses modifying signatures.  Note that there is not much difference between treating where's and share's as signature modifiers and as structure components, because two sub-structures with a where/share modifier on their signature(s) is nothing more than a where/share as a component of the surrounding structure.
    13. I agree with eliminating "val rec", let alone "val rec rec rec x = exp and rec y = exp'", etc  The real issue is that values are not recursive, only functions and lazy data structures such as streams are recursive.  rec is not a modifier of val.  Rather the syntax for functions introduces recursion as necessary, similarly for co-data-types.
    14. Syntax for compilation units, but whatever name they may be called.  These are not replaced by modules, and do not replace modules.
    15. Dropping open makes good sense to me.  I prefer structure X = BigStructureName to open BigStructureName, and writing X.t, etc.  Dropping include makes sense.
    16. Families of signatures are signatures with structure components, there is no difference, but one could support notation such as SIG (structure X = MyXModule), which is the same as SIG with structure X = MyXModule.  Done.
    17. Is "sealing" after all a good idea or not?  I can never make up my mind, to be honest.
    18. Karl's and my Twelf formulation of SML is the way to go.  Precise, verified, maintainable.
    19. Just like the "semicolon-as-separator vs semicolon-as-terminator" dispute, we can make "vertical-bar-as-initiator" instead of "vertical-bar-as separator" and we're good.  The first vertical bar is optional, but can always be there to initiate a series of clauses.  Done.
    20. "do e" would be handy.
    21. Agreed with dumping abstype, which I advocated 40 years ago.
    22. Disjunctive patterns are essential in some circumstances, and should be supported (as now).
    23. Calculi of records are not all that important, if you ask me.
    24. Line comments would be helpful imo.  Also nested bracketed comments.
    25. There are precedence issues with parsing fun patterns and fn patternss that lead to excessive parenthesization; these could be reconsidered.
